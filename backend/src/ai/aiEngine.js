import "dotenv/config";
import { GoogleGenAI } from "@google/genai";
import ExternalAPIsService from "../services/externalAPIs.js";

class AIEngine {
  constructor() {
    this.genAI = new GoogleGenAI({});
    this.model = "gemini-2.5-flash";
    this.externalAPIs = new ExternalAPIsService();
  }

  /**
   * Gera itiner√°rios hiper-personalizados baseados no perfil do usu√°rio
   * @param {Object} userProfile - Perfil do usu√°rio
   * @param {Object} tripDetails - Detalhes da viagem
   * @param {Array} realTimeData - Dados em tempo real (voos, hot√©is, atividades)
   * @returns {Object} Itiner√°rio personalizado com narrativa coerente
   */
  async generatePersonalizedItinerary(
    userProfile,
    tripDetails,
    realTimeData = null
  ) {
    try {
      const enrichedData = await this.collectRealTimeData(
        tripDetails,
        userProfile
      );

      const prompt = this.buildItineraryPrompt(
        userProfile,
        tripDetails,
        enrichedData
      );

      const response = await this.genAI.models.generateContent({
        contents: prompt,
        model: this.model,
      });
      const itinerary = response.text;

      return {
        success: true,
        itinerary: this.parseItineraryResponse(itinerary),
        personalizedFor: userProfile.id,
        dataEnrichment: enrichedData.sources, // Mostra quais APIs foram usadas
        generatedAt: new Date().toISOString(),
      };
    } catch (error) {
      console.error("Erro ao gerar itiner√°rio:", error);
      return {
        success: false,
        error: "Erro interno do sistema de IA",
        details: error.message,
      };
    }
  }

  /**
   * Constr√≥i o prompt otimizado para gera√ß√£o de itiner√°rios
   */
  buildItineraryPrompt(userProfile, tripDetails, enrichedData) {
    // Processa dados reais coletados das APIs
    const weatherInfo = enrichedData?.weather
      ? `
DADOS METEOROL√ìGICOS ATUAIS (${enrichedData.weather.source}):
- Temperatura atual: ${enrichedData.weather.currentWeather?.temperature}¬∞C
- Condi√ß√µes: ${enrichedData.weather.currentWeather?.description}
- Previs√£o: ${enrichedData.weather.forecast
          ?.map(
            (day) =>
              `${day.date}: ${day.temp}¬∞C, ${day.description}${
                day.rain > 0 ? ` (chuva: ${day.rain}mm)` : ""
              }`
          )
          .join("\n  ")}
- Recomenda√ß√µes meteorol√≥gicas: ${enrichedData.weather.recommendations?.join(
          ", "
        )}`
      : "";

    const restaurantInfo = enrichedData?.restaurants
      ? `
RESTAURANTES LOCAIS REAIS (${enrichedData.restaurants.source}):
${enrichedData.restaurants.restaurants
  ?.slice(0, 5)
  .map(
    (rest) =>
      `- ${rest.name} (‚≠ê ${rest.rating}) - ${rest.priceRange} - ${rest.recommendedFor}`
  )
  .join("\n")}`
      : "";

    const hotelInfo = enrichedData?.hotels
      ? `
HOT√âIS E ACOMODA√á√ïES REAIS (${enrichedData.hotels.source}):
${enrichedData.hotels.hotels
  ?.slice(0, 5)
  .map(
    (hotel) =>
      `- ${hotel.name} (‚≠ê ${hotel.rating}) - ${hotel.priceRange} - ${hotel.hotelType} - ${hotel.recommendedFor}`
  )
  .join("\n")}`
      : "";

    const exchangeInfo = enrichedData?.exchange
      ? `
TAXAS DE C√ÇMBIO ATUAIS (${enrichedData.exchange.source}):
${Object.entries(enrichedData.exchange.rates)
  .map(
    ([currency, info]) =>
      `- 1 BRL = ${info.rate.toFixed(4)} ${currency} ${info.symbol}`
  )
  .join("\n")}
- √öltima atualiza√ß√£o: ${enrichedData.exchange.lastUpdate}`
      : "";

    const transportInfo = enrichedData?.transport
      ? `
TRANSPORTE LOCAL DISPON√çVEL:
- Op√ß√µes: ${enrichedData.transport.recommendations?.join(", ")}`
      : "";

    const eventsInfo = enrichedData?.events
      ? `
EVENTOS LOCAIS NO PER√çODO:
${enrichedData.events.events
  ?.slice(0, 3)
  .map((event) => `- ${event.name}: ${event.description}`)
  .join("\n")}`
      : "";

    return `
Voc√™ √© um especialista em planejamento de viagens com conhecimento profundo sobre destinos globais. 
Sua tarefa √© criar um itiner√°rio HIPER-PERSONALIZADO que transcende listas b√°sicas e oferece uma experi√™ncia narrativa coerente.

PERFIL DO VIAJANTE:
- DNA de Viagem: ${userProfile.travelDNA || "Explorador curioso"}
- Prefer√™ncias: ${JSON.stringify(userProfile.preferences)}
- Or√ßamento: ${userProfile.budget || "Moderado"}
- Tipo de Acomoda√ß√£o: ${userProfile.accommodationType || "Conforto padr√£o"}
- Interesses: ${userProfile.interests?.join(", ") || "Cultura, gastronomia"}
- Sensibilidades: ${
      userProfile.sensitivities?.join(", ") || "Nenhuma especificada"
    }

DETALHES DA VIAGEM:
- Destino: ${tripDetails.destination}
- Dura√ß√£o: ${tripDetails.duration} dias
- Per√≠odo: ${tripDetails.startDate} a ${tripDetails.endDate}
- Viajantes: ${tripDetails.travelers} pessoas
- Tipo: ${tripDetails.tripType || "Lazer"}

üî• DADOS EM TEMPO REAL COLETADOS:
${weatherInfo}
${restaurantInfo}
${hotelInfo}
${exchangeInfo}
${transportInfo}
${eventsInfo}

DIRETRIZES PARA CRIA√á√ÉO (AGORA COM DADOS REAIS):
1. Crie uma NARRATIVA TEM√ÅTICA coerente, n√£o apenas uma lista
2. Equilibre PERFEITAMENTE or√ßamento, tempo, log√≠stica e interesses
3. USE OS RESTAURANTES REAIS listados acima nas recomenda√ß√µes
4. RECOMENDE OS HOT√âIS REAIS baseado no perfil e or√ßamento do usu√°rio
5. CONSIDERE AS CONDI√á√ïES METEOROL√ìGICAS para sugerir atividades apropriadas
6. INCLUA OS PRE√áOS EM MOEDA LOCAL usando as taxas de c√¢mbio atuais
7. OTIMIZE o transporte usando as op√ß√µes locais dispon√≠veis
8. MENCIONE os eventos locais quando relevantes
9. Inclua "joias escondidas" e experi√™ncias aut√™nticas locais
9. Sugira alternativas para diferentes cen√°rios (chuva, lota√ß√£o, etc.)
10. Inclua dicas pr√°ticas e contexto cultural
11. Personalize cada recomenda√ß√£o ao perfil espec√≠fico

FORMATO DE RESPOSTA (JSON):
{
    "tematicaNarrativa": "T√≠tulo tem√°tico do itiner√°rio",
    "resumoExecutivo": "Resumo em 2-3 frases do que torna esta viagem √∫nica",
    "fonteDados": "${enrichedData?.sources?.join(", ") || "Dados b√°sicos"}",
    "itinerarioDiario": [
        {
            "dia": 1,
            "tema": "Tema do dia",
            "condicoesTempo": "Baseado na previs√£o real",
            "atividades": [
                {
                    "horario": "09:00",
                    "atividade": "Nome da atividade",
                    "local": "Local espec√≠fico",
                    "duracao": "2h",
                    "motivoPersonalizacao": "Por que esta atividade √© perfeita para este viajante",
                    "dicas": ["Dica pr√°tica 1", "Dica pr√°tica 2"],
                    "alternativas": "O que fazer se chover/estiver lotado",
                    "custoEstimado": "Valor em moeda local com convers√£o BRL",
                    "transporteSugerido": "Como chegar usando transporte local"
                }
            ],
            "refeicoes": {
                "almoco": "Restaurante REAL da lista com justificativa",
                "jantar": "Restaurante REAL da lista com justificativa"
            },
            "hospedagem": "Hotel REAL da lista adequado ao perfil e or√ßamento",
            "logistica": "Como se deslocar, onde se hospedar, etc."
        }
    ],
    "recomendacoesHospedagem": {
        "hotelPrincipal": "Hotel REAL mais adequado ao perfil",
        "alternativas": ["Hotel alternativo 1", "Hotel alternativo 2"],
        "justificativa": "Por que este hotel √© ideal para este viajante"
    },
    "experienciasUnicas": ["Experi√™ncia 1", "Experi√™ncia 2"],
    "joiasEscondidas": ["Local secreto 1", "Local secreto 2"],
    "dicasEspecialistas": ["Dica 1", "Dica 2"],
    "orcamentoDetalhado": {
        "transporte": "Valor em moeda local (BRL)",
        "hospedagem": "Valor em moeda local (BRL)",
        "alimentacao": "Valor em moeda local (BRL)",
        "atividades": "Valor em moeda local (BRL)",
        "total": "Valor em moeda local (BRL)"
    },
    "consideracoesEspeciais": "Adapta√ß√µes baseadas no perfil do usu√°rio e dados reais coletados"
}

Crie agora o itiner√°rio hiper-personalizado usando os DADOS REAIS coletados:`;
  }

  /**
   * Processa e valida a resposta do modelo de IA
   */
  parseItineraryResponse(rawResponse) {
    try {
      // Remove markdown formatting se presente
      const cleanResponse = rawResponse
        .replace(/```json\n?/g, "")
        .replace(/```/g, "")
        .trim();
      return JSON.parse(cleanResponse);
    } catch (error) {
      console.error("Erro ao processar resposta da IA:", error);
      return {
        error: "Formato de resposta inv√°lido",
        rawResponse: rawResponse,
      };
    }
  }

  /**
   * Gera recomenda√ß√µes din√¢micas baseadas em contexto
   */
  async generateContextualRecommendations(context, userProfile) {
    try {
      const prompt = `
Como especialista em viagens, forne√ßa recomenda√ß√µes contextuais para:

CONTEXTO ATUAL: ${context.situation}
LOCALIZA√á√ÉO: ${context.currentLocation || "N√£o especificada"}
HORA: ${context.currentTime || new Date().toLocaleTimeString()}
CONDI√á√ïES: ${context.conditions || "Normais"}

PERFIL DO USU√ÅRIO: ${JSON.stringify(userProfile)}

Forne√ßa 3-5 recomenda√ß√µes espec√≠ficas para esta situa√ß√£o, considerando:
- Hor√°rio atual e disponibilidade
- Proximidade geogr√°fica
- Prefer√™ncias do usu√°rio
- Condi√ß√µes atuais (clima, multid√µes, etc.)

Formato: Lista numerada com justificativa para cada recomenda√ß√£o.`;

      const response = await this.genAI.models.generateContent({
        contents: prompt,
        model: this.model,
      });

      return {
        success: true,
        recommendations: response.text,
        context: context,
        generatedAt: new Date().toISOString(),
      };
    } catch (error) {
      console.error("Erro ao gerar recomenda√ß√µes contextuais:", error);
      return {
        success: false,
        error: "Erro ao processar recomenda√ß√µes",
      };
    }
  }

  /**
   * Otimiza itiner√°rios existentes baseado em feedback
   */
  async optimizeItinerary(currentItinerary, feedback, constraints) {
    try {
      const prompt = `
Voc√™ √© um especialista em otimiza√ß√£o de itiner√°rios. Analise o itiner√°rio atual e otimize baseado no feedback:

ITINER√ÅRIO ATUAL:
${JSON.stringify(currentItinerary)}

FEEDBACK DO USU√ÅRIO:
${feedback}

NOVAS RESTRI√á√ïES:
${JSON.stringify(constraints)}

TAREFA: Otimize o itiner√°rio mantendo a coer√™ncia narrativa, mas incorporando o feedback e restri√ß√µes.

Retorne o itiner√°rio otimizado no mesmo formato JSON, destacando as mudan√ßas feitas e a justificativa.`;

      const response = await this.genAI.models.generateContent({
        contents: prompt,
        model: this.model,
      });

      return {
        success: true,
        optimizedItinerary: this.parseItineraryResponse(response.text),
        changesApplied: feedback,
        optimizedAt: new Date().toISOString(),
      };
    } catch (error) {
      console.error("Erro ao otimizar itiner√°rio:", error);
      return {
        success: false,
        error: "Erro na otimiza√ß√£o do itiner√°rio",
      };
    }
  }

  /**
   * Intelig√™ncia Preditiva para Pre√ßos
   * Analisa dados hist√≥ricos e tend√™ncias para prever melhor momento de reserva
   */
  async predictOptimalBookingTime(tripDetails, preferences) {
    try {
      const prompt = `
Voc√™ √© um especialista em an√°lise de pre√ßos de viagens. Baseado nos dados hist√≥ricos e tend√™ncias do mercado:

DETALHES DA VIAGEM:
- Destino: ${tripDetails.destination}
- Datas: ${tripDetails.startDate} a ${tripDetails.endDate}
- Tipo: ${tripDetails.tripType}
- Flexibilidade: ${preferences.flexibility || "M√©dia"}

TAREFA: Forne√ßa recomenda√ß√µes sobre:
1. Melhor momento para reservar voos (anteced√™ncia ideal)
2. Tend√™ncia de pre√ßos para o per√≠odo
3. Alternativas de datas que podem economizar
4. Alertas de pre√ßo recomendados

Formato de resposta JSON:
{
  "recommendations": {
    "flightBooking": "Recomenda√ß√£o para voos",
    "hotelBooking": "Recomenda√ß√£o para hot√©is", 
    "priceAlert": "Configura√ß√£o de alerta",
    "alternativeDates": ["data1", "data2"],
    "savings": "Economia estimada seguindo as recomenda√ß√µes"
  }
}`;

      const response = await this.genAI.models.generateContent({
        contents: prompt,
        model: this.model,
      });

      return {
        success: true,
        predictions: this.parseItineraryResponse(response.text),
        generatedAt: new Date().toISOString(),
      };
    } catch (error) {
      console.error("Erro na previs√£o de pre√ßos:", error);
      return {
        success: false,
        error: "Erro na an√°lise preditiva de pre√ßos",
      };
    }
  }

  /**
   * Previs√£o de Multid√µes em Atra√ß√µes
   * Fornece insights sobre os melhores hor√°rios para visitar locais
   */
  async predictCrowdLevels(destinations, timeframe) {
    try {
      const prompt = `
Como especialista em fluxos tur√≠sticos, analise as seguintes atra√ß√µes e forne√ßa previs√µes de multid√µes:

DESTINOS/ATRA√á√ïES: ${destinations.join(", ")}
PER√çODO: ${timeframe.startDate} a ${timeframe.endDate}
√âPOCA DO ANO: ${new Date(timeframe.startDate).toLocaleDateString("pt-BR", {
        month: "long",
      })}

TAREFA: Para cada atra√ß√£o, forne√ßa:
1. Hor√°rios com menos movimento
2. Dias da semana ideais  
3. Per√≠odos a evitar
4. Alternativas menos conhecidas
5. Dicas para evitar filas

Formato JSON:
{
  "crowdPredictions": [
    {
      "location": "Nome do local",
      "bestTimes": ["hor√°rio1", "hor√°rio2"],
      "worstTimes": ["hor√°rio1", "hor√°rio2"], 
      "weekdayTrends": "An√°lise semanal",
      "alternatives": ["alternativa1", "alternativa2"],
      "tips": ["dica1", "dica2"]
    }
  ],
  "generalAdvice": "Conselhos gerais para o per√≠odo"
}`;

      const response = await this.genAI.models.generateContent({
        contents: prompt,
        model: this.model,
      });

      return {
        success: true,
        crowdPredictions: this.parseItineraryResponse(response.text),
        generatedAt: new Date().toISOString(),
      };
    } catch (error) {
      console.error("Erro na previs√£o de multid√µes:", error);
      return {
        success: false,
        error: "Erro na an√°lise preditiva de multid√µes",
      };
    }
  }

  /**
   * Gest√£o Proativa de Perturba√ß√µes
   * Monitora e sugere alternativas para problemas durante a viagem
   */
  async handleTravelDisruption(disruption, currentItinerary, userProfile) {
    try {
      const prompt = `
SITUA√á√ÉO DE EMERG√äNCIA/PERTURBA√á√ÉO DETECTADA:

TIPO DE PROBLEMA: ${disruption.type}
DETALHES: ${disruption.details}
IMPACTO: ${disruption.impact}
LOCALIZA√á√ÉO ATUAL: ${disruption.currentLocation}

ITINER√ÅRIO AFETADO:
${JSON.stringify(currentItinerary)}

PERFIL DO VIAJANTE:
${JSON.stringify(userProfile)}

TAREFA URGENTE: Forne√ßa solu√ß√µes imediatas e alternativas vi√°veis:

1. SOLU√á√ÉO IMEDIATA: O que fazer agora
2. ALTERNATIVAS VI√ÅVEIS: Op√ß√µes para reorganizar o plano
3. COMPENSA√á√ïES: Como minimizar o impacto na experi√™ncia
4. CONTATOS √öTEIS: Informa√ß√µes importantes para a situa√ß√£o
5. PLANO B: Itiner√°rio alternativo se necess√°rio

Seja pr√°tico, emp√°tico e focado em solu√ß√µes acion√°veis.

Formato JSON:
{
  "immediateSolution": "A√ß√£o imediata recomendada",
  "alternatives": ["alternativa1", "alternativa2"],
  "compensation": "Como compensar a experi√™ncia perdida", 
  "contacts": ["contato1", "contato2"],
  "revisedItinerary": "Itiner√°rio modificado se necess√°rio",
  "mood": "Mensagem encorajadora para o viajante"
}`;

      const response = await this.genAI.models.generateContent({
        contents: prompt,
        model: this.model,
      });

      return {
        success: true,
        solutions: this.parseItineraryResponse(response.text),
        disruption: disruption,
        resolvedAt: new Date().toISOString(),
      };
    } catch (error) {
      console.error("Erro na gest√£o de perturba√ß√µes:", error);
      return {
        success: false,
        error: "Erro na gest√£o de emerg√™ncias de viagem",
      };
    }
  }

  /**
   * üî• NOVA FUNCIONALIDADE: Coleta dados reais via APIs externas
   * Enriquece as recomenda√ß√µes com informa√ß√µes precisas e atualizadas
   */
  async collectRealTimeData(tripDetails, userProfile) {
    const dataCollectionPromises = [];
    const collectedData = {
      weather: null,
      restaurants: null,
      events: null,
      exchange: null,
      transport: null,
      sources: [],
    };

    try {
      // üå§Ô∏è Dados meteorol√≥gicos
      dataCollectionPromises.push(
        this.externalAPIs
          .getWeatherData(tripDetails.destination, {
            startDate: tripDetails.startDate,
            endDate: tripDetails.endDate,
          })
          .then((data) => {
            if (data.success) {
              collectedData.weather = data;
              collectedData.sources.push("OpenWeather/WeatherAPI");
            }
            return data;
          })
          .catch((err) => console.log("Weather API falhou:", err.message))
      );

      // üçΩÔ∏è Restaurantes locais
      if (
        userProfile.interests?.includes("gastronomia") ||
        userProfile.interests?.includes("culinaria")
      ) {
        dataCollectionPromises.push(
          this.externalAPIs
            .getRestaurantData(tripDetails.destination, userProfile.preferences)
            .then((data) => {
              if (data.success) {
                collectedData.restaurants = data;
                collectedData.sources.push("Foursquare/Google Places");
              }
              return data;
            })
            .catch((err) => console.log("Restaurant API falhou:", err.message))
        );
      }

      // üè® Hot√©is e acomoda√ß√µes
      if (tripDetails.duration > 1) {
        dataCollectionPromises.push(
          this.externalAPIs
            .getHotelData(tripDetails.destination, userProfile.preferences)
            .then((data) => {
              if (data.success) {
                collectedData.hotels = data;
                collectedData.sources.push("Foursquare Hotels");
              }
              return data;
            })
            .catch((err) => console.log("Hotel API falhou:", err.message))
        );
      }

      // üí± Taxas de c√¢mbio
      if (
        tripDetails.destination.includes("international") ||
        tripDetails.isInternational
      ) {
        dataCollectionPromises.push(
          this.externalAPIs
            .getExchangeRates("BRL", ["USD", "EUR", "GBP"])
            .then((data) => {
              if (data.success) {
                collectedData.exchange = data;
                collectedData.sources.push("ExchangeRate-API");
              }
              return data;
            })
            .catch((err) => console.log("Exchange API falhou:", err.message))
        );
      }

      // Aguarda todas as APIs (com timeout de 5 segundos)
      await Promise.allSettled(dataCollectionPromises);

      console.log(
        `‚úÖ Dados coletados de ${collectedData.sources.length} fontes:`,
        collectedData.sources
      );

      return collectedData;
    } catch (error) {
      console.error("Erro na coleta de dados externos:", error);
      return {
        ...collectedData,
        sources: ["Fallback - Dados b√°sicos apenas"],
      };
    }
  }
}

export default AIEngine;
